"""
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
"""
import sys
num=int(input())
dp=[]
for i in range(num):
  dp.append(list(map(int,sys.stdin.readline().split())))

for i in range(1,num):
    dp[i][0]= min(dp[i-1][1],dp[i-1][2])+dp[i][0]
    dp[i][1]=min(dp[i-1][0],dp[i-1][2])+dp[i][1]
    dp[i][2]=min(dp[i-1][0],dp[i-1][1])+dp[i][2]
print(min(dp[num-1]))

"""
처음엔 dp가 생각이 나지 않아서 for문으로 비교해서 작성했지만 자릿수는 줄이 넘어가면 중복이 가능한 점이 발목을 잡았다.
결국엔 정답을 참고해서 코드를 작성했다
dp[1][0]은 dp[0][1]과 dp[0][2]중 작은값과 dp[1][0]을 합친 값을 넣어준다.
이렇게 반복해서 최적의 합을 찾아낸다
마지막의 num값은 마지막 열에 합친값들이 들어가있는데 그 중에서 min값을 골라 출력해준다.
dp문제 응용의 시작이라 2차원 배열을 써야하는건 파악했지만 규칙을 구성하지 못해서 틀린 문제였다.
조금 더 문제의 구성을 파악하고 설계하는 능력을 키워야겠다.

"""