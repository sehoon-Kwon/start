import sys
a=int(sys.stdin.readline())

dp=[[0]*10 for _ in range(a+1)]
# 조건으로 0은 앞에올 수 없기 떄문에 0이아닌 1로 초기화해준다.
for i in range(1,10):
    dp[1][i]=1

#[i]=N자리수
#[j]=N자리일때 앞에 올 수 있는 일의자리 수
for i in range(2,a+1):
    for j in range(10):
        if j==0: # 뒷자리가 0이면 앞에는 1밖에 오지 못함 그래서 j+1만 
            dp[i][j]=dp[i-1][j+1]
        elif j==9: # 뒷자리가 9이면 앞에는 8밖에 오지 못함 그래서 j-1만
            dp[i][j]=dp[i-1][j-1]
        else: # 나머지는 앞에 숫자가 -1 +1 2개씩 올 수 있음
            dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]

print(sum(dp[a])%1000000000)

"""
인접한 모든 자리의 차이가 1인 수를 계단수라 하는데 a가 주어질떄 길이가 a인 계단수가 총 몇개인지 구하는것이다.
예를들어 a가 1이라면 1,2,3,4,5,6,7,8,9 총 9개이고 2라면 10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98 총 17개이다 
예시를 보면 알 수 있는것처럼 뒷자리가 0이라면 앞에는 1밖에 못오고 뒷자리가 9라면 앞에는 98밖에 오지 못한다. 나머지 숫자들은 총 2가지를 가지고 있다.
dp 문제를 풀다보니 2차원으로 푸는 문제가 점점 나오기 시작한다. 2차원까지 생각하면서 문제를 설계해봐야겠다. 지금까지 1차원 문제만 풀다보니 2차원에는 아직 적응이 안되어 바로바로 해결능력이 나오지 않는 것 같다.
얼른 익숙해 져야겠다.
"""