num=int(input())
dp=[]

for i in range(num):
    dp.append(int(input()))


dps=[[0 for _ in range(3)] for _ in range(100001)]
dps[1]=[1,0,0]
dps[2]=[0,1,0]
dps[3]=[1,1,1]
for i in range(4,100001):
    #만약 6이라면
    dps[i][0] = dps[i - 1][1] % 1000000009 + dps[i - 1][2] % 1000000009  # 6-1에서 2와 3으로 끝난거에 1 붙이기
    dps[i][1] = dps[i - 2][0] % 1000000009 + dps[i - 2][2] % 1000000009  # 6-2에서 1과 3으로 끝난거에 2붙이기
    dps[i][2] = dps[i - 3][0] % 1000000009 + dps[i - 3][1] % 1000000009  # 6-3에서 1과 2로 끝난거에 3 붙이기

for i in dp:
    print(sum(dps[i]) % 1000000009)

"""
전에 풀었던 1,2,3더하기의 확장형문제이다. 테스트케이스의 개수인 num이 주어지고
그 후에 정수가 주어지는데 1,2,3의 합으로 나타내는 방법을 구하는 문제이다. 단, 1+1+1와 같이 연속적인 수로 연산은 안된다.
예를들어 4를 1,2,3의 합으로 나타내려면 1+2+1, 1+3, 3+1와 같은 방법이다.
사실 처음에는 1차원 dp로 풀려고 경우의수를 찾아봤지만 결국엔 찾지 못했다. 그래서 정답코드를 분석하려고 코드를 보니 2차원으로 푸는것이다.
문제의 핵심은 마지막에 사용한 수를 기준으로 경우의 수를 구하고 전체를 합하는것이다
테스트캐이스를 dp에 넣어놓고 dps에는 [x][y] x에는 0,1,2 y에는 최대의 수인 100001에 0을 넣는다.
그리고 dps[1]은 마지막에 1을 사용한 경우 dps[2]에는 마지막에 2를 사용한 경우 dps[3]에는 마지막에 3을 사용한 경우를 i로 설정한다
1차원으로 계속 생각하다보니 어림도 없는 문제를 풀고 있었다. 생각의 크기를 넓혀야겠다.


"""