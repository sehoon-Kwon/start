num=int(input())
cnt=[0]
for i in range(num):
    cnt.append(int(input()))
dp= [0]
dp.append(cnt[1])
if num>1:
    dp.append(cnt[1]+cnt[2])
for i in range(3,num+1):
    dp.append(max(dp[i-1],dp[i-3]+cnt[i-1]+cnt[i],dp[i-2]+cnt[i]))
print(dp[num])

"""
숫자 : 6 10 13 9 8 1
num개수만큼 잔의 개수가 주어지는데 연속으로 3번 숫자를 가져올 수 없는 조건이있다 가장 최대의 수를 구하는 문제이다.
점화식이 구상이 안되서 고민하다가 정답코드를 보고 이해하기로했다.
먼저 cnt의 배열에 0을 넣어주고 그 후엔 숫자들을 차례로 넣어준다.
dp에도 마찬가지로 0을 넣고 dp[1]은 cnt[1]을 dp[2]에는 cnt[1]+cnt[2]를 고정값으로 넣어준다.
그 후 점화식으론 3가지중에 max값을 고르는건데 
1. i값을 선택하지 않는 경우 (dp[i-1])
2. i-1을 선택하지않고 i를 선택 (dp[i-3]+cnt[i-1]+cnt[i])
3. i-1을 선택하고 i를 선택 (dp[i-2]+cnt[i])
총 3가지 경우에서 max값을 구하는것이다.
이 문제는 사실 경우의 수 구하는게 힘들었다. 3번째부터 바뀌는건 눈치챘기 때문에 1, 2값을 고정값으로 두고 
풀어야한다는건 알았지만 그 후에 경우의 수를 구하는거에 좀 막혔었던 것 같다.
그래도 여러 dp문제를 접하다 보니까 구상의 지식은 늘고있는 것 같다. 
조금 더 경우의 수와 점화식을 구상하는데 머리를 써봐야겠다.
"""