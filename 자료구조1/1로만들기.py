n = int(input())

dp = [0 for _ in range(n+1)]

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1 #dp[2]에는 dp[1]보다 +1이다 왜? 2나 3으로 못나누면 무조건 -1해야하기때문

    if i%2 == 0 and dp[i] > dp[i//2] + 1 : #만약 i가 2로 나눠지고 dp[2]가 dp[0]+1보다 크다면 dp[2]는 dp[0]+1이 된다. 왜? 1을 안빼주고 2로 나눈 0의 값이 되고 연산 한번 했기 떄문에 +1해준다.
        dp[i] = dp[i//2]+1
        
    if i%3 == 0 and dp[i] > dp[i//3] + 1 : #마찬가지로 만약 i가 3으로 나눠지고 dp[3]이 dp[0]+1보다 크다면 dp[3]은 dp[0]+1이된다. 
        dp[i] = dp[i//3] + 1
        
print(dp[n])

"""
dp[1]은 이미 1이므로 연산은 필요없다 dp[1]은 0이다 그래서 2부터 for문을 돌려준다.
처음에는 그냥 if문으로 3이나 2로 안나눠지면 1을 빼주는 식으로 풀어봤지만 테스트케이스 몇개는 틀리고 시간초과가 떳다.
아직 다이나믹프로그래밍을 배운게 아니라서 정답코드를 분석하는 식으로 작성해보았다.
다이나믹 프로그래밍은 한번 결과를 수행한 것을 메모리에 저장하고 똑같은 결과가 필요하면 그때 메모리값을 가져와 쓰는것이다.

"""